# frozen_string_literal: true

#
#  Copyright 2021 Square, Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

require 'cocoapods-pack/gem_version'
require 'set'
require 'digest'

class SpecGenerator
  ROOT_ATTRIBUTES = %w[name version summary license authors homepage description social_media_url
                       docset_url documentation_url screenshots frameworks libraries requires_arc
                       deployment_target xcconfig pod_target_xcconfig user_target_xcconfig source vendored_frameworks
                       vendored_libraries resource_bundles resources preserve_paths cocoapods_version swift_versions].freeze
  PLATFORM_ATTRIBUTES = %w[frameworks libraries requires_arc xcconfig pod_target_xcconfig user_target_xcconfig].freeze

  attr_reader :podspec_path, :platforms, :artifact_repo_url, :staged_sources

  def initialize(source_podspec, artifact_repo_url, zip_output_path, staged_sources)
    @podspec_path = source_podspec
    @artifact_repo_url = artifact_repo_url
    @zip_output_path = zip_output_path
    @staged_sources = staged_sources
    @platforms = []
  end

  def generate_ruby_string
    root_attributes = hash_to_dsl(@podspec_path.attributes_hash.merge('source' => artifact_repo_hash), ROOT_ATTRIBUTES)
    sections = [root_attributes]
    sections << dependency_section
    sections.push(*platforms_sections)
    sections_str = sections.reject(&:empty?).map do |section|
      section.map { |lines| lines + "\n" }.join('')
    end.join("\n")
    "#{header}\n#{open}\n#{sections_str}#{close}\n"
  end

  def generate
    Pod::Specification.from_string(generate_ruby_string, "#{@podspec_path.name}.podspec")
  end

  def add_platform(platform, executable_name)
    @platforms << [platform, executable_name]
  end

  private

  def platform_spec(platform, executable_name, has_one_platform)
    ordered_keys = %w[platform source_files header_mappings_dir module_map vendored_frameworks vendored_libraries]
    platform_attributes_hash = @podspec_path.attributes_hash[platform.name.to_s] || {}
    platform_vendored_frameworks = Array(platform_attributes_hash['vendored_frameworks'])
    platform_vendored_libraries = Array(platform_attributes_hash['vendored_libraries'])
    hash = platform_spec_hash(platform.name, executable_name, platform_vendored_frameworks, platform_vendored_libraries)
    platform_prefix = "#{platform.name}."
    platform_section = []
    unless has_one_platform
      version = platform.deployment_target ? platform.deployment_target.version : nil
      platform_section << spec_line('deployment_target', version, platform_prefix)
    end
    platform_section.push(*hash_to_dsl(hash, ordered_keys, platform_prefix))
    platform_section.push(*hash_to_dsl(platform_attributes_hash, PLATFORM_ATTRIBUTES, platform_prefix)) if platform_attributes_hash
    platform_section
  end

  def platform_spec_hash(platform_name, product_name, vendored_frameworks, vendored_libraries)
    platform_hash = {}
    platform_hash['vendored_frameworks'] ||= []
    platform_hash['vendored_frameworks'] << "#{platform_name}/#{product_name}" if staged_sources
    platform_hash['vendored_frameworks'] += vendored_frameworks
    platform_hash['vendored_libraries'] = vendored_libraries
    platform_hash
  end

  def platforms_sections
    ret = []
    has_one_platform = (@platforms.size == 1)
    if has_one_platform
      platform, = @platforms.first
      ret << [spec_line('platform', platform_spec_line(platform))]
    end
    ret.push(*@platforms.map { |p, e| platform_spec(p, e, has_one_platform) })
    ret
  end

  def dependency_section
    @podspec_path.dependencies.map { |dependency| dependency_line(dependency) }
  end

  def platform_spec_line(platform)
    return [platform.symbolic_name] unless platform.deployment_target

    [platform.symbolic_name, platform.deployment_target.to_s]
  end

  def header
    "# Generated by cocoapods-pack #{CocoapodsPack::VERSION} - Do not manually modify."
  end

  def open
    'Pod::Spec.new do |s|'
  end

  def close
    'end'
  end

  def artifact_repo_hash
    { http: artifact_repo_url, sha256: Digest::SHA2.file(@zip_output_path).hexdigest }
  end

  def str(str)
    "'#{str.gsub(/\n/, '\n')}'"
  end

  def hash_to_dsl(hash, ordered_keys, extra_prefix = '')
    ret = []
    ordered_keys.each do |k|
      v = hash[k]
      ret << spec_line(k, v, extra_prefix) unless v.nil? || v == []
    end
    ret
  end

  def spec_line(key, value, extra_prefix = '')
    ['  ', 's.', extra_prefix, key.to_s, ' = ', value_of(value)].join('')
  end

  def dependency_line(dependency)
    name = dependency.name
    reqstr = dependency.requirement.as_list.map { |s| value_of(s) }.join(', ')
    ['  ', 's.dependency ', value_of(name), ', ', reqstr].join('')
  end

  def value_of(value)
    return str(quote_quotes(value)) if value.is_a?(String)
    return value.map { |x| value_of(x) }.join(', ') if value.is_a?(Array)

    quote_quotes(value.inspect)
  end

  def quote_quotes(str)
    str.gsub(/'/, "\\\\'")
  end
end
